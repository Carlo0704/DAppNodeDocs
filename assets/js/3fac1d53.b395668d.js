"use strict";(self.webpackChunkd_app_node_docs=self.webpackChunkd_app_node_docs||[]).push([[7533],{4137:(e,t,o)=>{o.d(t,{Zo:()=>d,kt:()=>m});var a=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function n(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,a)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?n(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):n(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,a,r=function(e,t){if(null==e)return{};var o,a,r={},n=Object.keys(e);for(a=0;a<n.length;a++)o=n[a],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)o=n[a],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var o=e.components,r=e.mdxType,n=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(o),u=r,m=c["".concat(l,".").concat(u)]||c[u]||h[u]||n;return o?a.createElement(m,i(i({ref:t},d),{},{components:o})):a.createElement(m,i({ref:t},d))}));function m(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var n=o.length,i=new Array(n);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<n;p++)i[p]=o[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,o)}u.displayName="MDXCreateElement"},1406:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>n,metadata:()=>s,toc:()=>p});var a=o(7462),r=(o(7294),o(4137));const n={},i="Smooth Validator States",s={unversionedId:"smooth/deep-dive-into-smooth/states",id:"smooth/deep-dive-into-smooth/states",title:"Smooth Validator States",description:"A Smooth validator can be in multiple states depending on its behavior. In this section we will explain all possible states a validator can have, the consequences of being each state, and how a validator can transition from one state to another.",source:"@site/docs/smooth/deep-dive-into-smooth/states.md",sourceDirName:"smooth/deep-dive-into-smooth",slug:"/smooth/deep-dive-into-smooth/states",permalink:"/docs/smooth/deep-dive-into-smooth/states",draft:!1,editUrl:"https://github.com/dappnode/DappnodeDocs/docs/smooth/deep-dive-into-smooth/states.md",tags:[],version:"current",frontMatter:{},sidebar:"smoothSidebar",previous:{title:"Rewards",permalink:"/docs/smooth/deep-dive-into-smooth/rewards"},next:{title:"Smooth's architecture",permalink:"/docs/smooth/deep-dive-into-smooth/oracle-sm"}},l={},p=[{value:"State Machine Overview",id:"state-machine-overview",level:2},{value:"The purpose of the State Machine",id:"the-purpose-of-the-state-machine",level:2}],d={toc:p},c="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"smooth-validator-states"},"Smooth Validator States"),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"https://smooth.dappnode.io/"},"Smooth")," validator can be in multiple states depending on its behavior. In this section we will explain all possible states a validator can have, the consequences of being each state, and how a validator can transition from one state to another."),(0,r.kt)("h2",{id:"state-machine-overview"},"State Machine Overview"),(0,r.kt)("p",null,"The oracle employs a ",(0,r.kt)("strong",{parentName:"p"},"state machine")," to monitor the status of subscribed validators within ",(0,r.kt)("a",{parentName:"p",href:"https://smooth.dappnode.io/"},"Smooth"),". Various actions trigger state changes, detailed in the following image encompassing all possible transitions. Let's take a look at it:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"statemachine",src:o(2060).Z,width:"2998",height:"1494"})),(0,r.kt)("p",null,"There are 6 different states a validator can have:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\ud83d\udfe2 ",(0,r.kt)("strong",{parentName:"li"},"Active"),": The validator is active and subscribed to the pool, earning rewards over time. "),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udfe1 ",(0,r.kt)("strong",{parentName:"li"},"YellowCard"),": The validator missed its last block proposal but not two in a row. This validator earns rewards as if it was active."),(0,r.kt)("li",{parentName:"ul"},"\ud83d\udd34 ",(0,r.kt)("strong",{parentName:"li"},"RedCard"),": The validator missed its latest two block proposals in a row. As a penalty, the validator does not earn rewards until its next block is successfully proposed to the pool. In other words, this validator is not receiving ",(0,r.kt)("inlineCode",{parentName:"li"},"Pending Rewards")," when somebody else contributes to the pool. "),(0,r.kt)("li",{parentName:"ul"},"\u26aa ",(0,r.kt)("strong",{parentName:"li"},"NotSubscribed"),": The validator is no longer subscribed to the pool, but still tracked by the validator. For example, a validator that unsubscribed. Note that this is still tracked because a validator can unsubscribe but it may still have pending balance to claim. In this state, the validator does not earn rewards. "),(0,r.kt)("li",{parentName:"ul"},"\u2620\ufe0f ",(0,r.kt)("strong",{parentName:"li"},"Banned"),": The validator is banned forever from the pool. A validator is banned when it is subscribed to the pool but proposes a block with the wrong fee recipient. "),(0,r.kt)("li",{parentName:"ul"},"\u2753",(0,r.kt)("strong",{parentName:"li"},"Untracked"),": The validator is not tracked by the pool. It has never subscribed to the pool. ")),(0,r.kt)("p",null,"And 6 different actions can trigger a state transition:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ProposalOk"),": The validator proposed a valid block with its rewards correctly sent to the smoothing pool address."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ProposalMissed"),": The validator should have proposed a block but missed its proposal."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ProposalWrongFee"),": The validator proposes a block but with a wrong fee recipient."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ManualSubscription"),": The validator manually subscribes to the pool, depositing collateral for its validator index by calling the smart contract function (see event)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AutoSubscription"),": The validator is automatically subscribed to the pool, by setting as fee recipient the smoothing pool address."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Unsubscribe"),": The validator manually unsubscribes to the pool, calling the unsubscribe function from the smart contract (see event).")),(0,r.kt)("h2",{id:"the-purpose-of-the-state-machine"},"The purpose of the State Machine"),(0,r.kt)("p",null,"Beyond tracking validator statuses, the state machine ensures fair reward distribution and encourages correct behavior among validators."),(0,r.kt)("p",null,"Validators consistently proposing blocks receive greater rewards compared to those frequently missing proposals, promoting active participation and contribution to the pool."))}h.isMDXComponent=!0},2060:(e,t,o)=>{o.d(t,{Z:()=>a});const a=o.p+"assets/images/smooth_states-1ba74d83a78fa2e0b740effe50c30ee8.png"}}]);