"use strict";(self.webpackChunkd_app_node_docs=self.webpackChunkd_app_node_docs||[]).push([[7533],{4137:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var o=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,o,r=function(e,t){if(null==e)return{};var a,o,r={},n=Object.keys(e);for(o=0;o<n.length;o++)a=n[o],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(o=0;o<n.length;o++)a=n[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=o.createContext({}),p=function(e){var t=o.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var a=e.components,r=e.mdxType,n=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(a),m=r,u=c["".concat(l,".").concat(m)]||c[m]||h[m]||n;return a?o.createElement(u,i(i({ref:t},d),{},{components:a})):o.createElement(u,i({ref:t},d))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var n=a.length,i=new Array(n);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<n;p++)i[p]=a[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,a)}m.displayName="MDXCreateElement"},1406:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>n,metadata:()=>s,toc:()=>p});var o=a(7462),r=(a(7294),a(4137));const n={},i="Smooth Validator States",s={unversionedId:"smooth/deep-dive-into-smooth/states",id:"smooth/deep-dive-into-smooth/states",title:"Smooth Validator States",description:"A Smooth validator can be in multiple states depending on its behavior. In this section we will explain all possible states a validator can have, the consequences of being each state, and how a validator can transition from one state to another.",source:"@site/docs/smooth/deep-dive-into-smooth/states.md",sourceDirName:"smooth/deep-dive-into-smooth",slug:"/smooth/deep-dive-into-smooth/states",permalink:"/docs/smooth/deep-dive-into-smooth/states",draft:!1,editUrl:"https://github.com/dappnode/DappnodeDocs/docs/smooth/deep-dive-into-smooth/states.md",tags:[],version:"current",frontMatter:{},sidebar:"smoothSidebar",previous:{title:"Rewards",permalink:"/docs/smooth/deep-dive-into-smooth/rewards"},next:{title:"Smooth's architecture",permalink:"/docs/smooth/deep-dive-into-smooth/oracle-sm"}},l={},p=[{value:"State Machine Overview",id:"state-machine-overview",level:2},{value:"The purpose of the State Machine",id:"the-purpose-of-the-state-machine",level:2}],d={toc:p},c="wrapper";function h(e){let{components:t,...a}=e;return(0,r.kt)(c,(0,o.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"smooth-validator-states"},"Smooth Validator States"),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"https://smooth.dappnode.io/"},"Smooth")," validator can be in multiple states depending on its behavior. In this section we will explain all possible states a validator can have, the consequences of being each state, and how a validator can transition from one state to another."),(0,r.kt)("h2",{id:"state-machine-overview"},"State Machine Overview"),(0,r.kt)("p",null,"The oracle employs a ",(0,r.kt)("strong",{parentName:"p"},"state machine")," to monitor the status of subscribed validators within ",(0,r.kt)("a",{parentName:"p",href:"https://smooth.dappnode.io/"},"Smooth"),". Various actions trigger state changes, detailed in the following image encompassing all possible transitions. Let's take a look at it:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://github.com/dappnode/mev-sp-oracle/blob/main/spec/states.png?raw=true",alt:"statemachine"})),(0,r.kt)("p",null,"There are 5 different states a validator can have:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Active"),": A validator is active and subscribed to the pool, earning rewards over the time."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"YellowCard"),": The validator missed only its last block proposal, but still earns rewards."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"RedCard"),": The validator missed two block proposals in a row. In this state the validator does not earn rewards until a valid block has been proposed by it. In other words, this validator is not recieving ",(0,r.kt)("inlineCode",{parentName:"li"},"Pending Rewards")," when somebody contributes to the pool."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"NotSubscribed"),": The validator is no longer subscribed to the pool, but still tracked by the validator. For example, a validator that unsubscribed. Note that this is still tracked because a validator can unsubscribe but it may still have pending balance to claim. In this state the validator does not earn rewards."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Banned"),": The validator is banned forever from the pool. ",(0,r.kt)("strong",{parentName:"li"},"A validator is banned when its subscribed to the pool but proposes a block with the wrong fee recipient"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Untracked"),": The validator is not tracked by the pool. It never subscribed before nor has any active subscription.")),(0,r.kt)("p",null,"And 6 different actions can trigger a state transition:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ProposalOk"),": The validator proposed a valid block with its rewards correctly sent to the smoothing pool address."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ProposalMissed"),": The validator should have proposed a block but missed its proposal."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ProposalWrongFee"),": The validator proposes a block but with a wrong fee recipient."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ManualSubscription"),": The validator manually subscribes to the pool, depositing collateral for its validator index by calling the smart contract function (see event)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AutoSubscription"),": The validator is automatically subscribed to the pool, by setting as fee recipient the smoothing pool address."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Unsubscribe"),": The validator manually unsubscribes to the pool, calling the unsubscribe function from the smart contract (see event).")),(0,r.kt)("h2",{id:"the-purpose-of-the-state-machine"},"The purpose of the State Machine"),(0,r.kt)("p",null,"Beyond tracking validator statuses, the state machine ensures fair reward distribution and encourages correct behavior among validators."),(0,r.kt)("p",null,"Validators consistently proposing blocks receive greater rewards compared to those frequently missing proposals, promoting active participation and contribution to the pool."))}h.isMDXComponent=!0}}]);